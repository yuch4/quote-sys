# 発注・入荷管理機能 詳細設計書

## 1. 機能概要

### 1.1 目的
見積明細の仕入要否に基づき、発注書の作成、入荷登録、進捗管理を行い、調達業務の効率化を実現する。

### 1.2 主要機能
- 発注書作成（見積明細から自動/手動）
- 発注承認フロー
- 入荷登録
- 調達進捗ダッシュボード
- 長期未入荷アラート
- 活動記録（商談・連絡履歴）

---

## 2. データモデル

### 2.1 purchase_ordersテーブル

```sql
CREATE TABLE public.purchase_orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  purchase_order_number TEXT NOT NULL UNIQUE,
  quote_id UUID REFERENCES public.quotes(id),
  supplier_id UUID NOT NULL REFERENCES public.suppliers(id),
  order_date DATE NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('未発注', '発注済', 'キャンセル')) DEFAULT '未発注',
  total_cost DECIMAL(15, 2) NOT NULL DEFAULT 0,
  notes TEXT,
  created_by UUID NOT NULL REFERENCES public.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### 2.2 purchase_order_itemsテーブル

```sql
CREATE TABLE public.purchase_order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  purchase_order_id UUID NOT NULL REFERENCES public.purchase_orders(id) ON DELETE CASCADE,
  quote_item_id UUID REFERENCES public.quote_items(id),
  manual_name TEXT,
  manual_description TEXT,
  quantity DECIMAL(10, 2) NOT NULL,
  unit_cost DECIMAL(15, 2) NOT NULL,
  amount DECIMAL(15, 2) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### 2.3 procurement_activitiesテーブル（活動記録）

```sql
CREATE TABLE public.procurement_activities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  quote_item_id UUID NOT NULL REFERENCES public.quote_items(id),
  activity_type TEXT NOT NULL CHECK (activity_type IN ('発注', '入荷', '出荷準備完了', '連絡', 'その他')),
  activity_date DATE NOT NULL,
  notes TEXT,
  created_by UUID NOT NULL REFERENCES public.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

---

## 3. 画面設計

### 3.1 発注候補一覧（/dashboard/procurement/pending）

#### 表示条件
- 見積ステータス = '承認済み'
- 明細の requires_procurement = true
- 明細の procurement_status = '未発注'

#### 表示項目
- 案件名、顧客名、見積番号
- 品名、説明、数量、仕入先
- 仕入単価、仕入金額
- チェックボックス（一括選択用）

#### 機能
- 複数明細を選択して一括発注書作成
- 発注日の設定
- 仕入先でフィルタ

### 3.2 発注書一覧（/dashboard/procurement/purchase-orders）

#### 表示項目
- 発注番号、仕入先、発注日
- ステータス、承認ステータス
- 合計金額、作成者、作成日

#### 機能
- 検索（発注番号、仕入先名）
- フィルタ（ステータス、承認ステータス、期間）
- 新規発注書作成ボタン

### 3.3 発注書作成画面（ダイアログ）

#### 入力項目
- 見積選択（ドロップダウン）
- 仕入先選択（必須）
- 発注日（必須、デフォルト: 今日）
- 明細（見積明細から自動取得 or 手動入力）
  - 品名、説明、数量、仕入単価、金額
- 備考

#### 発注番号の自動採番

```typescript
const generatePurchaseOrderNumber = async () => {
  const supabase = createClient()
  const year = new Date().getFullYear()
  const { count } = await supabase
    .from('purchase_orders')
    .select('*', { count: 'exact', head: true })
  
  const nextNumber = (count || 0) + 1
  return `PO-${year}-${String(nextNumber).padStart(4, '0')}`
}
```

### 3.4 入荷登録画面（/dashboard/procurement/receiving）

#### 検索機能
- 案件名、顧客名、品名で検索
- procurement_status = '発注済' でフィルタ

#### 入荷登録フォーム
- 明細選択（テーブルから選択）
- 入荷日（デフォルト: 今日）
- 入荷数量
- 出荷可能日
- 備考

#### 入荷登録処理

```typescript
const registerReceiving = async (itemId: string, data: {
  received_date: string
  quantity: number
  shipment_ready_date: string
  notes: string
}) => {
  const supabase = createClient()
  
  // quote_items更新
  await supabase
    .from('quote_items')
    .update({
      procurement_status: '入荷済',
      received_at: new Date(data.received_date).toISOString(),
      shipment_ready_date: data.shipment_ready_date,
    })
    .eq('id', itemId)

  // procurement_activities記録
  await supabase
    .from('procurement_activities')
    .insert({
      quote_item_id: itemId,
      activity_type: '入荷',
      activity_date: data.received_date,
      notes: data.notes,
      created_by: user.id,
    })

  // 営業担当にメール通知
  await sendEmail({
    type: 'receiving_notification',
    ...
  })

  toast.success('入荷を登録しました')
}
```

### 3.5 進捗ダッシュボード（/dashboard/procurement）

#### 表示内容
- **発注済・未入荷の明細一覧**
  - 案件名、顧客名、品名
  - 発注日、経過日数
  - 出荷可能予定日
  - アラート表示（14日以上経過）

#### カード統計
- 発注済・未入荷: ○件
- 本日入荷予定: ○件
- 長期未入荷（14日以上）: ○件

#### アラート機能

```typescript
// 14日以上未入荷の明細を取得
const getLongDelayItems = async () => {
  const supabase = createClient()
  const fourteenDaysAgo = new Date()
  fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14)

  const { data } = await supabase
    .from('quote_items')
    .select(`
      *,
      quote:quotes!inner(
        quote_number,
        project:projects!inner(
          project_name,
          customer:customers(customer_name)
        )
      ),
      supplier:suppliers(supplier_name)
    `)
    .eq('procurement_status', '発注済')
    .lte('ordered_at', fourteenDaysAgo.toISOString())

  return data || []
}
```

### 3.6 活動記録（/dashboard/procurement/activity）

#### 表示内容
- 活動日、活動種別、案件名、品名
- 備考、実行者、記録日時

#### 活動登録フォーム
- 明細選択
- 活動種別（発注/入荷/出荷準備完了/連絡/その他）
- 活動日
- 備考

---

## 4. 発注承認フロー

### 4.1 承認フロー

```
発注書作成
  ↓ status = '未発注', approval_status = '承認待ち'
営業事務・管理者が承認
  ↓ approval_status = '承認済み', status = '発注済'
仕入先に発注
  ↓ quote_items.procurement_status = '発注済', ordered_at = 現在日時
入荷登録
  ↓ quote_items.procurement_status = '入荷済', received_at = 入荷日
```

### 4.2 承認処理実装

```typescript
// 発注書承認
const approvePurchaseOrder = async (poId: string) => {
  const supabase = createClient()
  
  // purchase_orders更新
  await supabase
    .from('purchase_orders')
    .update({
      status: '発注済',
    })
    .eq('id', poId)

  // purchase_order_approval_instances更新
  await supabase
    .from('purchase_order_approval_instances')
    .update({
      status: 'approved',
      current_step: null,
    })
    .eq('purchase_order_id', poId)

  // 対応するquote_items更新
  const { data: poItems } = await supabase
    .from('purchase_order_items')
    .select('quote_item_id')
    .eq('purchase_order_id', poId)

  await Promise.all(
    poItems
      .filter(item => item.quote_item_id)
      .map(item =>
        supabase
          .from('quote_items')
          .update({
            procurement_status: '発注済',
            ordered_at: new Date().toISOString(),
          })
          .eq('id', item.quote_item_id!)
      )
  )

  toast.success('発注書を承認しました')
}
```

---

## 5. CSV/Excelエクスポート

### 5.1 発注データエクスポート

```typescript
import * as XLSX from 'xlsx'

const exportPurchaseOrders = async () => {
  const supabase = createClient()
  
  const { data: pos } = await supabase
    .from('purchase_orders')
    .select(`
      purchase_order_number,
      supplier:suppliers(supplier_name),
      order_date,
      status,
      total_cost,
      items:purchase_order_items(
        product_name:quote_items(product_name),
        manual_name,
        quantity,
        unit_cost,
        amount
      )
    `)
    .eq('status', '発注済')

  // データ整形
  const rows = pos.flatMap(po =>
    po.items.map(item => ({
      発注番号: po.purchase_order_number,
      仕入先: po.supplier?.supplier_name,
      発注日: po.order_date,
      品名: item.manual_name || item.product_name,
      数量: item.quantity,
      単価: item.unit_cost,
      金額: item.amount,
    }))
  )

  // Excelワークブック作成
  const ws = XLSX.utils.json_to_sheet(rows)
  const wb = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(wb, ws, '発注一覧')

  // ダウンロード
  XLSX.writeFile(wb, `発注一覧_${new Date().toISOString().split('T')[0]}.xlsx`)
}
```

---

## 6. 通知機能

### 6.1 入荷通知メール

```typescript
// lib/email/send.ts

export async function sendReceivingNotification(itemId: string) {
  const supabase = await createClient()

  const { data: item } = await supabase
    .from('quote_items')
    .select(`
      *,
      quote:quotes!inner(
        quote_number,
        project:projects!inner(
          project_name,
          customer:customers(customer_name),
          sales_rep:users!projects_sales_rep_id_fkey(email, display_name)
        )
      )
    `)
    .eq('id', itemId)
    .single()

  if (!item?.quote?.project?.sales_rep?.email) return

  await sendEmail({
    type: 'receiving_notification',
    recipientEmail: item.quote.project.sales_rep.email,
    recipientName: item.quote.project.sales_rep.display_name,
    projectName: item.quote.project.project_name,
    customerName: item.quote.project.customer.customer_name,
    productName: item.product_name,
    receivedDate: new Date(item.received_at).toLocaleDateString('ja-JP'),
    shipmentReadyDate: new Date(item.shipment_ready_date).toLocaleDateString('ja-JP'),
  })
}
```

### 6.2 長期未入荷アラート（Cron）

```typescript
// app/api/cron/daily-alerts/route.ts

export async function GET(request: Request) {
  // Vercel Cronからの呼び出しのみ許可
  const authHeader = request.headers.get('authorization')
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('Unauthorized', { status: 401 })
  }

  const supabase = await createClient()

  // 14日以上未入荷の明細を取得
  const fourteenDaysAgo = new Date()
  fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14)

  const { data: longDelayItems } = await supabase
    .from('quote_items')
    .select(`
      *,
      quote:quotes!inner(
        quote_number,
        project:projects!inner(
          project_name,
          customer:customers(customer_name)
        )
      ),
      supplier:suppliers(supplier_name)
    `)
    .eq('procurement_status', '発注済')
    .lte('ordered_at', fourteenDaysAgo.toISOString())

  if (!longDelayItems || longDelayItems.length === 0) {
    return Response.json({ message: 'No long delay items' })
  }

  // 営業事務・管理者にメール送信
  const { data: adminUsers } = await supabase
    .from('users')
    .select('email, display_name')
    .in('role', ['営業事務', '管理者'])
    .eq('is_active', true)

  await Promise.all(
    adminUsers.map(user =>
      sendEmail({
        type: 'long_delay_alert',
        recipientEmail: user.email,
        recipientName: user.display_name,
        items: longDelayItems.map(item => ({
          productName: item.product_name,
          projectName: item.quote.project.project_name,
          customerName: item.quote.project.customer.customer_name,
          supplierName: item.supplier?.supplier_name || '未設定',
          orderedDate: new Date(item.ordered_at).toLocaleDateString('ja-JP'),
          daysElapsed: Math.floor(
            (new Date().getTime() - new Date(item.ordered_at).getTime()) / (1000 * 60 * 60 * 24)
          ),
        })),
      })
    )
  )

  return Response.json({ message: 'Alert sent', count: longDelayItems.length })
}
```

---

## 7. RLSポリシー

```sql
-- purchase_orders閲覧（営業事務・管理者のみ）
CREATE POLICY "営業事務・管理者のみ発注書閲覧可能"
ON purchase_orders FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('営業事務', '管理者')
  )
);

-- purchase_orders作成（営業事務・管理者のみ）
CREATE POLICY "営業事務・管理者のみ発注書作成可能"
ON purchase_orders FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('営業事務', '管理者')
  )
);
```

---

## 8. パフォーマンス最適化

### 8.1 インデックス

```sql
CREATE INDEX idx_purchase_orders_supplier_id ON purchase_orders(supplier_id);
CREATE INDEX idx_purchase_orders_quote_id ON purchase_orders(quote_id);
CREATE INDEX idx_purchase_order_items_po_id ON purchase_order_items(purchase_order_id);
CREATE INDEX idx_quote_items_procurement_status ON quote_items(procurement_status);
CREATE INDEX idx_quote_items_ordered_at ON quote_items(ordered_at);
```

---

## 9. テスト

### 9.1 E2Eテスト

```typescript
// e2e/procurement-flow.spec.ts

test('発注・入荷フロー', async ({ page }) => {
  // 発注候補から発注書作成
  await page.goto('/dashboard/procurement/pending')
  await page.check('input[type="checkbox"]')
  await page.click('text=発注書作成')
  
  // 発注書作成ダイアログ
  await page.selectOption('select[name="supplier_id"]', '...')
  await page.click('button:has-text("作成")')
  
  // 承認
  await page.goto('/dashboard/procurement/purchase-orders')
  await page.click('text=承認')
  
  // 入荷登録
  await page.goto('/dashboard/procurement/receiving')
  await page.fill('input[type="date"]', '2025-01-15')
  await page.click('button:has-text("入荷登録")')
  
  // 入荷完了確認
  await expect(page.locator('text=入荷済')).toBeVisible()
})
```

---

## 10. 今後の拡張
- 発注書PDF生成
- 仕入先ポータル（入荷予定通知）
- 在庫管理連携
- 発注履歴分析（仕入先評価）
- 自動発注機能（閾値設定）
