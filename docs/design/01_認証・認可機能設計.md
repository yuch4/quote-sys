# 認証・認可機能 詳細設計書

## 1. 機能概要

### 1.1 目的
Supabase Authを使用した安全なユーザー認証と、役割ベースのアクセス制御（RBAC）を実現する。

### 1.2 主要機能
- メールアドレス・パスワード認証
- ログイン/ログアウト
- セッション管理
- 役割ベースアクセス制御（営業、営業事務、管理者）
- Row Level Security（RLS）によるデータアクセス制御

---

## 2. データモデル

### 2.1 usersテーブル

```sql
CREATE TABLE public.users (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  display_name TEXT NOT NULL,
  department TEXT,
  role TEXT NOT NULL CHECK (role IN ('営業', '営業事務', '管理者')),
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### 2.2 TypeScript型定義

```typescript
export type UserRole = '営業' | '営業事務' | '管理者'

export interface User {
  id: string
  email: string
  display_name: string
  department: string | null
  role: UserRole
  is_active: boolean
  created_at: string
  updated_at: string
}
```

---

## 3. 認証フロー

### 3.1 ログインフロー

```
ユーザー
  ↓ メール・パスワード入力
ログインページ (/login)
  ↓ supabase.auth.signInWithPassword()
Supabase Auth
  ↓ 認証成功
セッション確立
  ↓ middleware.tsで検証
ダッシュボード (/dashboard)
```

### 3.2 セッション管理フロー

```
リクエスト
  ↓
middleware.ts
  ↓ updateSession()
Supabaseセッション検証
  ↓ 
  ├─ 有効 → 次の処理へ
  └─ 無効 → /login へリダイレクト
```

---

## 4. 実装詳細

### 4.1 Supabaseクライアント

#### 4.1.1 サーバーサイド用（/lib/supabase/server.ts）

```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Server Componentから呼ばれた場合、cookieの設定は無視される
          }
        },
      },
    }
  )
}
```

**使用場所**: Server Components, Server Actions, API Routes

#### 4.1.2 クライアントサイド用（/lib/supabase/client.ts）

```typescript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

**使用場所**: Client Components

#### 4.1.3 ミドルウェア用（/lib/supabase/middleware.ts）

```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            request.cookies.set(name, value)
            supabaseResponse.cookies.set(name, value, options)
          })
        },
      },
    }
  )

  const {
    data: { user },
  } = await supabase.auth.getUser()

  // 認証が必要なパスで未認証の場合、ログインページへリダイレクト
  if (!user && !request.nextUrl.pathname.startsWith('/login')) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // 認証済みユーザーがログインページにアクセスした場合、ダッシュボードへリダイレクト
  if (user && request.nextUrl.pathname === '/login') {
    const url = request.nextUrl.clone()
    url.pathname = '/dashboard'
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}
```

**使用場所**: middleware.ts

### 4.2 ログインページ（/app/(auth)/login/page.tsx）

#### 4.2.1 主要機能
- メールアドレス・パスワード入力
- ログイン処理
- エラーハンドリング
- ログイン成功後のリダイレクト

#### 4.2.2 実装例

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'

export default function LoginPage() {
  const router = useRouter()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  })

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    setError(null)

    try {
      const supabase = createClient()
      const { error } = await supabase.auth.signInWithPassword({
        email: formData.email,
        password: formData.password,
      })

      if (error) {
        setError('ログインに失敗しました: ' + error.message)
        return
      }

      router.push('/dashboard')
      router.refresh()
    } catch (err) {
      setError('予期しないエラーが発生しました')
    } finally {
      setLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="email">メールアドレス</Label>
        <Input
          id="email"
          type="email"
          value={formData.email}
          onChange={(e) => setFormData({ ...formData, email: e.target.value })}
          required
          disabled={loading}
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="password">パスワード</Label>
        <Input
          id="password"
          type="password"
          value={formData.password}
          onChange={(e) => setFormData({ ...formData, password: e.target.value })}
          required
          disabled={loading}
        />
      </div>

      {error && (
        <div className="rounded-md bg-red-50 p-3 text-sm text-red-800">
          {error}
        </div>
      )}

      <Button type="submit" className="w-full" disabled={loading}>
        {loading ? 'ログイン中...' : 'ログイン'}
      </Button>
    </form>
  )
}
```

### 4.3 ログアウト処理

```typescript
// components/layout/user-menu.tsx の一部

const handleLogout = async () => {
  const supabase = createClient()
  await supabase.auth.signOut()
  router.push('/login')
  router.refresh()
}
```

### 4.4 認証状態の取得

#### 4.4.1 Server Componentでの取得

```typescript
import { createClient } from '@/lib/supabase/server'

export default async function DashboardPage() {
  const supabase = await createClient()
  
  // 現在のユーザー取得
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    redirect('/login')
  }

  // ユーザー情報取得
  const { data: userData } = await supabase
    .from('users')
    .select('*')
    .eq('id', user.id)
    .single()

  return (
    <div>
      <h1>ようこそ、{userData?.display_name}さん</h1>
    </div>
  )
}
```

#### 4.4.2 Client Componentでの取得

```typescript
'use client'

import { useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import type { User } from '@/types/database'

export default function UserProfile() {
  const [user, setUser] = useState<User | null>(null)

  useEffect(() => {
    const fetchUser = async () => {
      const supabase = createClient()
      const { data: { user: authUser } } = await supabase.auth.getUser()
      
      if (authUser) {
        const { data } = await supabase
          .from('users')
          .select('*')
          .eq('id', authUser.id)
          .single()
        
        setUser(data)
      }
    }

    fetchUser()
  }, [])

  if (!user) return <div>Loading...</div>

  return <div>{user.display_name}</div>
}
```

---

## 5. Row Level Security（RLS）

### 5.1 RLSポリシー設計方針

各テーブルにRLSを有効化し、役割に応じたアクセス制御を実装。

### 5.2 主要RLSポリシー

#### 5.2.1 案件テーブル（projects）

```sql
-- 営業は自分の案件のみ閲覧可能、営業事務・管理者は全て閲覧可能
CREATE POLICY "営業は自分の案件のみ閲覧可能"
ON projects FOR SELECT
USING (
  auth.uid() = sales_rep_id OR
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('営業事務', '管理者')
  )
);

-- 営業は案件作成可能
CREATE POLICY "営業は案件作成可能"
ON projects FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.is_active = true
  )
);

-- 営業は自分の案件のみ更新可能、営業事務・管理者は全て更新可能
CREATE POLICY "営業は自分の案件のみ更新可能"
ON projects FOR UPDATE
USING (
  auth.uid() = sales_rep_id OR
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role IN ('営業事務', '管理者')
  )
);
```

#### 5.2.2 見積テーブル（quotes）

```sql
-- 案件を閲覧できるユーザーは見積も閲覧可能
CREATE POLICY "案件権限で見積閲覧"
ON quotes FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM projects
    WHERE projects.id = quotes.project_id
    AND (
      auth.uid() = projects.sales_rep_id OR
      EXISTS (
        SELECT 1 FROM users
        WHERE users.id = auth.uid()
        AND users.role IN ('営業事務', '管理者')
      )
    )
  )
);

-- 営業は見積作成可能
CREATE POLICY "営業は見積作成可能"
ON quotes FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.is_active = true
  ) AND
  EXISTS (
    SELECT 1 FROM projects
    WHERE projects.id = quotes.project_id
    AND auth.uid() = projects.sales_rep_id
  )
);
```

#### 5.2.3 ユーザーテーブル（users）

```sql
-- 全ユーザーは自分のプロフィール閲覧可能、管理者は全て閲覧可能
CREATE POLICY "ユーザーは自分のプロフィール閲覧可能"
ON users FOR SELECT
USING (
  auth.uid() = id OR
  EXISTS (
    SELECT 1 FROM users u
    WHERE u.id = auth.uid()
    AND u.role = '管理者'
  )
);

-- ユーザーは自分のプロフィール更新可能
CREATE POLICY "ユーザーは自分のプロフィール更新可能"
ON users FOR UPDATE
USING (auth.uid() = id);

-- 管理者のみユーザー作成可能
CREATE POLICY "管理者のみユーザー作成可能"
ON users FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role = '管理者'
  )
);
```

---

## 6. 役割ベースアクセス制御（RBAC）

### 6.1 役割定義

| 役割 | 権限 |
|------|------|
| **営業** | - 自分の案件・見積の作成・編集・閲覧<br>- 計上申請<br>- 自分の通知閲覧 |
| **営業事務** | - 全案件・見積の閲覧<br>- 発注管理（作成・編集・削除）<br>- 入荷登録<br>- 計上承認・却下<br>- CSVエクスポート<br>- 全通知閲覧 |
| **管理者** | - 全権限<br>- ユーザー管理（作成・編集・無効化）<br>- マスタ管理（顧客・仕入先）<br>- システム設定 |

### 6.2 画面アクセス制御

```typescript
// Server Componentで役割チェック
export default async function AdminPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    redirect('/login')
  }

  const { data: userData } = await supabase
    .from('users')
    .select('*')
    .eq('id', user.id)
    .single()

  if (userData?.role !== '管理者') {
    redirect('/dashboard')
  }

  // 管理者専用処理
  return <div>管理者ページ</div>
}
```

### 6.3 機能レベルアクセス制御

```typescript
// ユーティリティ関数
export function canApproveQuote(userRole: UserRole): boolean {
  return ['営業事務', '管理者'].includes(userRole)
}

export function canManageUsers(userRole: UserRole): boolean {
  return userRole === '管理者'
}

export function canExportData(userRole: UserRole): boolean {
  return ['営業事務', '管理者'].includes(userRole)
}

// 使用例
if (canApproveQuote(userData.role)) {
  // 承認ボタン表示
}
```

---

## 7. セキュリティ対策

### 7.1 パスワードポリシー
- 最小8文字以上
- 英数字を含む（Supabase Auth標準設定）

### 7.2 セッション管理
- JWTトークンの有効期限: 1時間（デフォルト）
- リフレッシュトークン: 7日間（デフォルト）
- 自動ログアウト: セッション期限切れ時

### 7.3 HTTPS通信
- 本番環境では必ずHTTPS使用
- Vercelデプロイ時に自動で有効化

### 7.4 CSRF対策
- Next.js標準のCSRF保護を使用

### 7.5 XSS対策
- Reactの自動エスケープ機能
- dangerouslySetInnerHTMLは使用しない

---

## 8. エラーハンドリング

### 8.1 認証エラー

| エラー | 原因 | 対応 |
|--------|------|------|
| Invalid login credentials | メール・パスワード不一致 | エラーメッセージ表示 |
| Email not confirmed | メール未確認 | 確認メール再送案内 |
| User not found | ユーザー存在しない | エラーメッセージ表示 |
| Too many requests | レート制限 | 時間をおいて再試行案内 |

### 8.2 認可エラー

| エラー | 原因 | 対応 |
|--------|------|------|
| Unauthorized | セッション無効 | ログインページへリダイレクト |
| Forbidden | 権限不足 | 403エラーページ表示 |
| RLS violation | RLSポリシー違反 | エラーメッセージ + ログ記録 |

---

## 9. テスト

### 9.1 単体テスト
- Supabaseクライアント生成のテスト
- 役割チェック関数のテスト

### 9.2 E2Eテスト（Playwright）

```typescript
// e2e/basic-login.spec.ts
test('ログイン成功', async ({ page }) => {
  await page.goto('/login')
  await page.fill('input[type="email"]', 'test@example.com')
  await page.fill('input[type="password"]', 'password123')
  await page.click('button[type="submit"]')
  await expect(page).toHaveURL('/dashboard')
})

test('ログイン失敗', async ({ page }) => {
  await page.goto('/login')
  await page.fill('input[type="email"]', 'test@example.com')
  await page.fill('input[type="password"]', 'wrongpassword')
  await page.click('button[type="submit"]')
  await expect(page.locator('text=ログインに失敗しました')).toBeVisible()
})
```

---

## 10. パフォーマンス考慮事項

### 10.1 セッション検証の最適化
- middleware.tsでの効率的なセッション検証
- 不要なデータベースクエリを避ける

### 10.2 RLSポリシーの最適化
- インデックスの適切な設定
- 複雑な結合を避けたポリシー設計

---

## 11. 今後の拡張

- 多要素認証（MFA）対応
- ソーシャルログイン（Google、Microsoft）
- パスワードリセット機能
- ユーザー招待機能
- セッション管理画面（複数デバイスログイン管理）
