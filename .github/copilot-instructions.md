# 統合開発ルール: Dev Workflow + Vibe Coding & Anti-Fragmentation（新ルール）

## 0. 目的
-  「処理の連続性（Linearity）」と「局所的な振る舞い（Locality of Behavior）」を最優先にし、
  仕様確認 → 実装 → コミット → タスク更新 をブレなく回す。
-  読む人がコードジャンプ無しで理解・修正できる状態を維持する。

---

## 1. コミュニケーション / 応答ルール（AIの振る舞い）
### 1.1 会話言語
-  日本語を使用する。

### 1.2 回答フォーマット
-  すべての回答の先頭に「💡」を必ず付与する。

### 1.3 コード提示時の要件
-  コードを提供した後は、必ず「実装された主要な機能の1文要約」を付ける。
  形式: _実装機能: ..._

---

## 2. タスク運用（/todo.md）
### 2.1 /todo.md の存在保証
-  プロジェクトルートに `/todo.md` が存在しない場合、要件定義書をもとに新規作成する。

### 2.2 /todo.md に含める内容
-  実装すべき機能一覧
-  優先順位
-  完了状態（未完了 / 進行中 / 完了）

### 2.3 実装フロー（必須）
1) 実装前に `/todo.md` を確認
2) 実装順序を考慮し、未完了タスクから優先的に選ぶ
3) 実装する
4) 変更が成功するたびにコミットする（Conventional Commits）
5) 完了後 `/todo.md` を更新する（状態・優先度・追加タスクがあれば追記）

フロー図:
要件定義 → /todo.md作成/確認 → 未完了タスク選択 → 実装 → コミット → todo.md更新

---

## 3. Git コミット規約（Conventional Commits）
### 3.1 フォーマット
<タイプ>: <説明>

### 3.2 タイプ
| タイプ | 用途 |
|:---|:---|
| feat | 新機能の追加 |
| fix | バグ修正 |
| refactor | バグ修正や機能追加を伴わないコード変更 |
| docs | ドキュメントの変更 |
| chore | 定型業務（ビルド、依存関係更新など） |

### 3.3 原則
-  簡潔かつ適切に説明する
-  日本語で記述する

例:
-  feat: ユーザー認証機能を追加
-  fix: ログイン時のバリデーションエラーを修正
-  refactor: 決済処理のコードを整理

---

## 4. Supabase 運用ルール
-  supabase を使ってマイグレーション等を実行する際は、
  supabase CLI ではなく supabase mcp を使用すること。

---

## 5. コーディング指針: Vibe Coding & Anti-Fragmentation
## 5.1 基本姿勢（最重要）
-  コードは「上から下へ」読めること。読解に関数間ジャンプを要求しないこと。
-  関連する変数・分岐・変換・副作用は近接配置（Colocation）すること。
-  “整理のための分割”で、情報を分散させる行為を禁止する。

## 5.2 思考プロセスと設計（トップダウンコメント必須）
-  いきなり実装を書かない。
-  まず main / handler / usecase の最上位関数内に、処理シーケンスを日本語コメントで物語のように書く。
-  そのコメントの直下に、同じ順番で実装を書く（コメントと実装がズレたらコメントを更新する）。

### コメントの書き方（推奨）
-  セクション見出しを固定化して「現在地」を失わせない（関数化の代わり）:
  # --- 1) 入力取得と検証 ---
  # --- 2) 変換・計算（できるだけ純粋） ---
  # --- 3) 永続化・送信などの副作用 ---
-  1セクションが長い場合はサブセクション見出しで分割する。
-  目安: 1セクション 30〜80 行。超えるならサブセクション化し、変数スコープを締める。

## 5.3 実装ルール（過剰なメソッド分割の禁止）
### 5.3.1 禁止事項
-  「1箇所でしか呼ばれない処理」を別メソッド/関数に切り出すことを禁止。
-  “名前を付けただけ”の薄い関数（中身が数行・単なるラップ）を量産しない。
-  可読性を理由にした分割で、参照ジャンプを発生させない。

### 5.3.2 ネスト対策（ガード節推奨）
-  インデントを深くしない。Happy Path は常に左端を維持する。
-  ガードは早期return / 例外 / Result返却のいずれでも良い（目的はネストを深くしないこと）。
-  NG: if (条件) { 長い処理 }
-  OK: ガード失敗を即時終了させ、成功ルートを直線で書く。

### 5.3.3 例外（切り出しを許可する条件）
次のいずれかを満たす場合のみ許可。満たさないなら原則インライン。

A) 明確に「3回以上」異なる場所から再利用される汎用ロジック

B) 一貫性が価値で、統一しないと事故りやすい“純粋ロジック”
-  例: 日付/時刻丸め、金額計算、正規化、パース、エスケープ、権限判定など
-  条件:
  - DB/ネットワーク/ファイルアクセスなし
  - 入出力が明確
  - 単体テストが必須な複雑さ
  - 注意: 乱数・現在時刻取得・グローバル状態参照・環境変数参照・ロガー書き込みも副作用扱い（原則呼び出し側）

C) 言語/フレームワークの制約で構造化が必須（例: インターフェース実装、コールバック要件）

※例外で切り出した場合でも、呼び出し直前に「何のために呼ぶか」を短いコメントで補足する。
※例外Bは「純粋ロジックである」ことをコメントで明示する。

## 5.4 直線性を保ったままメンテナンス性を上げる
### 5.4.1 変数とスコープ
-  変数は「使う直前に定義」し、「使い終わったら下に持ち越さない」。
-  重要な中間データは、意味が分かる名前を付ける（過剰な抽象化は不要）。

### 5.4.2 I/O と純粋ロジックの混線を避ける（分割不要）
-  同じ関数内でも、並びを固定する:
  1) 入力取得・検証（I/O & Guard）
  2) 変換・計算（Logic: 副作用を持たせない）
  3) 永続化・送信（I/O）

### 5.4.3 副作用（Side Effects）の整合性
-  副作用セクションでは、失敗時の整合性方針（トランザクション/補償/リトライ）をコメントで明示する。
-  「決済→保存」など整合性が壊れやすい順序の場合は、設計意図が読み取れるように書く。

---

## 6. AI 最終チェック（出力前に必ず満たす）
-  [ ] 先頭に「💡」が付いている
-  [ ] 日本語で回答している
-  [ ] （コード提示時）主要機能の1文要約を付けている
-  [ ] 実装前に /todo.md を確認する前提で進めている（存在しなければ作成方針を示す）
-  [ ] 変更が成功するたびに Conventional Commits でコミットする
-  [ ] Supabase は supabase mcp を使う
-  [ ] Vibe Coding: トップダウンの処理シーケンスコメント → 同順実装
-  [ ] 1回呼び出しの処理を関数化していない（例外を除く）
-  [ ] ガード節でネストを浅くし Happy Path を直線にしている
-  [ ] 副作用の整合性方針がコメントで明示されている
